# 基本概念

## 硬盘

**硬盘是数据的载体。**但是数据不能直接存进去，需要分区才可以使用（可以理解为数据管理。数据存到了哪里都会被记录，后期还需要继续读写）。然而我们分区又分为：

### 主分区：

可以理解为硬盘分出来的一部分区域，用于存储数据，比如我们的 C 盘，一般作为启动分区。**主分区可以存在多个，但是至少需要一个。**

### 拓展分区：

分完主分区了，剩下的部分区域，一般就是拓展分区（除非你想浪费部分空间）。所以**拓展分区最多只能有一个。**

### 逻辑分区：

**逻辑分区依赖于拓展分区**，因为硬盘不能直接使用来存储数据，而拓展分区时剩余的部分区域，也是不能直接使用的，想要使用，我们就必须在拓展分区上继续划分逻辑分区。拓展分区上的逻辑分区可以有多个。

# 分区表

创建了分区，分区容量、起始位置等分区信息就是存储在分区表，分区表常用有两种：MBR 分区表、GPT 分区表。

## MBR 分区表

在 MBR 分区表中最多 4 个主分区或者最多 3 个主分区 +1 个扩展分区，也就是说扩展分区只能有一个，其它的都是主分区，但是它们的总个数不能超过 4 个，且单个主分区的最大容量为 2TB（=2048GB）。

## GPT 分区表

GPT 分区表：在 GPT 分区表中，主分区和拓展分区个数最多为 128 个，但是拓展分区最多只有 1 个，而且单个主分区的大小最大容量为 18EB（=18432PB =18874368TB =19327352832GB）

# 操作分区

## 查看当前分区和硬盘设备

如果你插上硬盘，当前 Linux 识别到的话就会在 `/dev` 目录下列出：

![img](https://img2024.cnblogs.com/blog/1033563/202411/1033563-20241109170811230-128078251.png)

在这里 `/dev/sda` 是硬件设备， `/dev/sda1` 这种则是分区。

除了使用这种方法，还可以使用 `sudo fdisk -l` 命令来查看：

![img](https://img2024.cnblogs.com/blog/1033563/202411/1033563-20241109171953497-1632105734.png)

还可以使用 `fdisk` 命令：

![img](https://img2024.cnblogs.com/blog/1033563/202411/1033563-20241109173022608-1740311497.png)

## 创建分区

### fdisk

fdisk 是一个较老的分区表创建和管理工具，它可以用来创建、删除、调整分区大小等，支持 MBR 分区表（貌似最新版也在开始支持 GPT 分区表），也就是说 fdisk 创建的分区最大为 2T。

### 创建分区类型

#### GPT

直接按下 `g` 即可

#### MBR

直接按下 `o` 即可

> 下面拿 MBR 做例

### 主分区

开始分区：`sudo fdisk /dev/sdb`，注意，这里 /dev/sdb 是我的设备。![img](https://img2024.cnblogs.com/blog/1033563/202411/1033563-20241109174640993-1301506126.png)

这样我们就创建了一个主分区，我们可以通过 `sudo fdisk -l /dev/sdb` 来查看：

![img](https://img2024.cnblogs.com/blog/1033563/202411/1033563-20241109174801107-1246062654.png)

### 拓展分区

如果要创建一个拓展分区，输入的命令类似，只是类型是拓展分区，这里演示我就是用来剩余的全部空间：![img](https://img2024.cnblogs.com/blog/1033563/202411/1033563-20241109175446697-1632283122.png)

#### 逻辑分区

有了拓展分区，我们还可以创建逻辑分区：![](https://img2024.cnblogs.com/blog/1033563/202411/1033563-20241110152015646-1708419983.png)

一切完成后输入 `w` 即可保存退出

## parted

### 创建分区类型

#### GPT

如果要创建一个 GPT 类型的分区表，可以使用 `mklabel gpt`

#### MBR

同上，只不过命令换成了 `mklabel msdos`

### 主分区

![img](https://img2024.cnblogs.com/blog/1033563/202411/1033563-20241110182032450-1751343810.png)

输入  `mkpart primary 0GB 5GB` 创建主分区（`mkpart` 命令也可以通过百分比来指定，例如：`mkpart primary 0% 50%`）

### 拓展分区

![img](https://img2024.cnblogs.com/blog/1033563/202411/1033563-20241110182106283-386672141.png)

如果还需要拓展分区，可以输入 `mkpart extended 5GB 100%` 创建一个拓展分区

#### 逻辑分区

> **注意，这里创建逻辑分区时，起始位置和截止位置必须在拓展分区内，它不是相对于拓展分区的起始位置**

![img](https://img2024.cnblogs.com/blog/1033563/202411/1033563-20241110182554498-1055876728.png)

有了 `mkpart logical 5GB 7GB` 拓展分区，还可以创建逻辑分区，输入创建一个逻辑分区

一切完成后输入 `quit` 即可退出。

## 格式化分区

> 上一步创建了三个分区：主分区 `/dev/sdb1`、拓展分区 `/dev/sdb2`、逻辑分区 `/dev/sdb5`，下面就拿这三个分区来举例子。

在分区创建完成后，需要先格式化才能进行使用。格式化分区用的命令是 `sudo mkfs.xxx /dev/xxx` 其中 mkfs 后面的 xxx 接的是文件系统，Linux 中常用的文件系统有：

- ext4：**稳定** 用的最多
- xfs：**性能高**
- btrfs：**前沿，具备快照恢复功能** 性能有点弱

### 查看格式化后的分区类型

如果我们需要查看一个分区的文件系统时什么类型，可以通过 `sudo lsblk -f /dev/sdb `命令查看

![img](https://img2024.cnblogs.com/blog/1033563/202411/1033563-20241110182943261-1644039501.png)

# 挂载分区

## 指定挂载地点

在挂载分区前，需要先创建目录或者是用系统中已经有的目录。

## 挂载

挂载分区请使用 `mount` 命令，基本用法是 `mount [分区] [目录]`。

### 取消挂载

取消挂载直接用 `unmount`，后面跟着挂载地点

### 查看挂载情况

挂载后可以通过 `df -Th` 命令查看挂载情况![img](https://img2024.cnblogs.com/blog/1033563/202411/1033563-20241110152915543-283971840.png)

## 开机自动挂载

要做到开机自动挂载，就需要去编辑 `fstab` 这个文件，它位于 `etc` 目录下面。

```shell
# 添加之后重启系统就可以开机自动挂载了。
	/dev/sdb1      /mnt/sdb1   ext4  defaults   0    1
    /dev/sdb5      /mnt/sdb5   xfs   defaults   0    1
```

## fstab 讲解

### 简单的 fstab 文件

```shell
$ cat /etc/fstab 

# <file system>        <dir>         <type>    <options>             <dump> <pass>
tmpfs                  /tmp          tmpfs     nodev,nosuid          0      0
/dev/sda1              /             ext4      defaults,noatime      0      1
/dev/sda2              none          swap      defaults              0      0
/dev/sda3              /home         ext4      defaults,noatime      0      2
```

#### 每个部分的含义

在这个文件中，包含了许多字段：

##### file system

file system 指明了要挂载的分区或存储设备. 设备名称，LABEL，UUID，伪文件系统名称。

##### dir

dir 指定了 file system 的挂载位置。

##### type

要挂载设备或是分区的文件系统类型，支持许多种不同的文件系统：ext2, ext3, ext4, reiserfs, xfs, jfs,  smbfs, iso9660, vfat, ntfs, swap 及 auto。 设置成 auto 类型，mount  命令会猜测使用的文件系统类型，对 移动设备是非常有用的。

##### options

挂载时使用的参数，注意**有些 mount 参数是特定文件系统才有的**。一些比较常用的参数有：

- auto：在启动时或键入了 mount -a  命令时自动挂载。
- noauto：只在你的命令下被挂载。
- exec：允许执行此分区的二进制文件。
- noexec： 不允许执行此文件系统上的二进制文件。
- ro：以只读模式挂载文件系统。
- rw：以读写模式挂载文件系统。
- user： 允许任意用户挂载此文件系统，若无显示定义，隐含启用 noexec, nosuid, nodev 参数。
- users：允许所有 users  组中的用户挂载文件系统.nouser：只能被 root 挂载。
- owner：允许设备所有者挂载.sync：I/O 同步进行。
- async：I/O 异步进行。
- dev：解析文件系统上的块特殊设备。
- nodev：不解析文件系统上的块特殊设备。
- suid：允许 suid  操作和设定 sgid 位。这一参数通常用于一些特殊任务，使一般用户运行程序时临时提升权限。nosuid：禁止 suid 操作和设定 sgid 位。
- noatime：不更新文件系统上 inode 访问记录，可以提升性能(参见 atime 参数)。
- nodiratime： 不更新文件系统上的目录 inode 访问记录，可以提升性能(参见 atime 参数)。
- relatime：实时更新 inode access  记录。只有在记录中的访问时间早于当前访问才会被更新。（与 noatime 相似，但不会打断如 mutt  或其它程序探测文件在上次访问后是否被修改的进程。），可以提升性能(参见 atime 参数)。
- flush：vfat  的选项，更频繁的刷新数据，复制对话框或进度条在全部数据都写入后才消失。
- defaults：使用文件系统的默认挂载参数，例如 ext4  的默认参数为:rw, suid, dev, exec, auto, nouser, async.

##### dump

dump 工具通过它决定何时作备份。dump 会检查其内容，并用数字来决定是否对这个文件系统进行备份。 允许的数字是 0 和 1 。**0  表示忽略， 1 则进行备份**。大部分的用户是没有安装 dump 的 ，对他们而言 dump 这个参数应设为 0。**转储频率：  0表示不进行dump备份，1代表每天进行dump备份，2代表不定日期的进行dump备份。**

##### pass

>如果设备不小心被破坏，开机自检不过，无法正常启用，该怎么办？ 原理很简单，只需要修复一下文件系统就好了，（如果不能修复，可以去`/etc/fstab`中把自检改为0） 

fsck 读取 pass 的数值来决定需要检查的文件系统的检查顺序。允许的数字是 0，1，和 2。**根目录应当获得最高的优先权  1，其它所有需要被检查的设备设置为 2，0 表示设备不会被 fsck  所检查。**开机时自检（非 0），自检次序：（如果开机系统自检不过，就无法正常开机）0：不自检 1：最先自检，一般为/ 2…：数越小优先级最大。

# 扩容分区

在创建完成分区之后可以进行扩容分区，可以使用 `extend` 命令去进行扩容。
